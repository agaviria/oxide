use std::str::FromStr;

use argonautica::{
	self,
	config::{Variant, Version},
	{Hasher, Verifier},
	input::SecretKey,
};
use crate::error::{Error, ErrorKind, ParseError};
use failure::format_err;

const SALT_SIZE : usize = 32;

enum HashVersion {
	V1,
}

/// Hash Version v1
impl HashVersion {
	pub fn from_hash(hash: &str) -> Option<HashVersion> {
		let version: String = hash.chars().take_while(|c| c != &'$').collect();
		match version.as_ref() {
			"1" => Some(HashVersion::V1),
			_   => None,
		}
	}
}

/// Hashing algorithm v1, using Argon2id variant with 256-bit salt.
pub struct V1Hash {
	pub salt: [u8; SALT_SIZE],
	pub hash: [u8; 32],
}

impl V1Hash {

	/// String hash method.
	#[allow(dead_code)]
	pub fn hash_password(password: &str) -> Result<Self, Error> {
		use crate::random;

		let salt = random::generate_random_byte_array();
		let slen = salt.len();

		// validate salt size
		if !(slen == 32) {
			return Err(
				ErrorKind::Msg(format!(
						"Expected salt size (32), got salt size({})",
						slen)).into())
		}

		let encrypt = argon2id(password, &salt)?;
		let mut hash = [0u8; 32];
		for (&x, p) in encrypt.into_bytes()
			.iter().zip(hash.iter_mut()){
				*p = x;
		}

		Ok (V1Hash { salt, hash })
	}

	/// Checks password with Argon2.
	pub fn check(&self, password: &str) -> Result<bool, Error> {
		let key = load_env_var("SECRET_KEY")?;
		let mut verifier = Verifier::new();
		let is_valid = if verifier
			.with_secret_key(&key)
			.with_password(password)
			.verify()
			.is_ok()
		{
			true
		} else {
			false
		};

		Ok(is_valid)

	}

	/// takes in &[u8] and validates len size on `salt`, `hash` types of V1Hash.
	pub fn from_bytes<B: AsRef<[u8]>, C: AsRef<[u8]>>(b0: B, b1: C) ->
		Result<Self, ParseError> {
			let salt_byte = b0.as_ref();
			let hash_byte= b1.as_ref();
			validate!(
				salt_byte.len() != 32 || hash_byte.len() != 32,
				ParseError::InvalidLen
			);
			let mut salt = [0u8; 32];
			let mut hash = [0u8; 32];
			salt.copy_from_slice(salt_byte);
			hash.copy_from_slice(hash_byte);
			Ok(V1Hash { salt, hash } )
	}
}

impl FromStr for V1Hash {
	type Err = ParseError;

	fn from_str(s: &str) -> Result<Self, ParseError> {
		let parts: Vec<_> = s.split('$').collect();
		validate!(parts.len() != 3, ParseError::InvalidVecLen);
		validate!(parts[0] != "1", ParseError::InvalidSlice);

		let vec_salt = base64::decode(parts[1])
			.map_err(|e| ParseError::DecodeError(e))?;

		let vec_hash = base64::decode(parts[2])
			.map_err(|e| ParseError::DecodeError(e))?;

		let v1hash_from_bytes = V1Hash::from_bytes(&vec_salt, &vec_hash)?;

		let salt = v1hash_from_bytes.salt;
		let hash = v1hash_from_bytes.hash;

		Ok(Self { salt, hash })
	}
}

/// ToString implementation for V1Hash
impl ToString for V1Hash {
	fn to_string(&self) -> String {
		let as_str = format!(
			"1${}${}",
			// base64::encode(&self.salt).as_ref(),
			base64::encode(&self.salt),
			// base64::encode(&self.hash).as_ref(),
			base64::encode(&self.hash),
		);
		as_str
	}
}

/// Into() String implementation for V1Hash
impl Into<String> for V1Hash {
	fn into(self) -> String {
		self.to_string()
	}
}

/// argon2id algorithm hashes a password for login sessions
pub fn argon2id(pwd: &str, salt: &[u8]) -> Result<String, Error> {
	let key = load_env_var("SECRET_KEY")?;

	let mut a2id = Hasher::default();
	let raw_hash = a2id
		.configure_hash_len(32)
		.configure_variant(Variant::Argon2id)
		.configure_version(Version::_0x13)
		.with_password(pwd)
		.with_salt(salt)
		.with_secret_key(key);

	let hash_encoded = raw_hash.hash()?;
	Ok(hash_encoded)
}

/// Check a password against a hash which has been generated by this crate.
pub fn check_password(pwd: &str, hash: &str) -> bool {
	match HashVersion::from_hash(hash) {
		Some(HashVersion::V1) => {
			let v1_hash: V1Hash = match hash.parse() {
				Ok(v1_hash) => v1_hash,
				Err(_) => return false,
			};

			v1_hash.check(pwd).unwrap()
		}
		None => false,
	}
}

/// gets environment variable
///
/// TODO: Use thread-safe cell for static reference of jwt_key and secret_key.
pub fn load_env_var(env: &str) -> Result<SecretKey<'static>, Error> {
	let _path = dotenv::from_path("../sentry.env")
		.map_err(|e|
			format_err!(
				"Failed to load env file. Cause: {}", e
			))?;
	let env_var = std::env::var(env)
		.expect("Please inspect env variable exists");

	Ok(SecretKey::from_base64_encoded(&env_var)?)
}

#[cfg(test)]
mod test {
	use super::*;
	#[test]
	pub fn known_hash() {
		// In order to test the argon2id function we must make nonce deterministic.
		// Nonce should always be random bytes in production.
		let nonce = [66, 67, 80, 97, 35, 48, 7, 89, 112, 112, 32, 225, 83, 134, 76, 117, 159, 143, 191, 83, 140, 8, 239, 14, 53, 253, 105, 206, 71, 108, 116, 12];
		let crypt = argon2id("WY5cpFbAY0ns", &nonce).unwrap();
		let encrypted: String = base64::encode(&crypt).into();
		assert_eq!(
			encrypted,
			"JGFyZ29uMmlkJHY9MTkkbT00MDk2LHQ9MTkyLHA9OCRRa05RWVNNd0IxbHdjQ0RoVTRaTWRaK1B2MU9NQ084T05mMXB6a2RzZEF3JFcxYW5VQlBaUnUvYlFJR3E2aHBqMkorNytCOVg2SmtzZUY0dUpBM0xid0E="
		);
	}
	#[test]
	pub fn hash_roundtrip() {
		use crate::random;

		for _ in 0..10 {
			let password: String = random::password();

			let v1_hash: String = V1Hash::hash_password(&password).unwrap().into();
			eprintln!("{:?}", v1_hash);
			assert!(true, check_password(&password, &v1_hash))
		}
	}
}
